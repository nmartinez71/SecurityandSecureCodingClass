# Broken Access Control
# 1

app.get('/profile/:userId', (req, res) => {
    const requestedUserId = req.params.userId;
    const currentUserId = req.user.id;  

    if (requestedUserId !== currentUserId) {
        return res.status(403).send("Forbidden: You cannot access this profile");
    }

    User.findById(requestedUserId, (err, user) => {
        if (err) return res.status(500).send(err);
        res.json(user);
    });
});


# 2

@app.route('/account/<user_id>')
def get_account(user_id):
    current_user = get_identity()
    
    if current_user['id'] != user_id and not current_user.get('is_admin'):
        return jsonify({'error': 'Forbidden'}), 403
    
    user = db.query(User).filter_by(id=user_id).first()
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    user_dict = user.to_dict()
    user_dict.pop('password', None)
    user_dict.pop('reset_token', None)
    
    return jsonify(user_dict)

# Cryptographic Failures
# 3

def hash_password(password):
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(password, hashed):
    # Verify password against stored hash
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

# 4

def hash_password(password):
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(password, hashed):
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

# Injection
# 5

String username = request.getParameter("username");
String query = "SELECT * FROM users WHERE username = ?";
PreparedStatement stmt = connection.prepareStatement(query);
stmt.setString(1, username);
ResultSet rs = stmt.executeQuery();

# 6

app.get('/user', (req, res) => {
    const username = req.query.username;
    if (typeof username !== 'string' || !username) {
        return res.status(400).json({ error: 'Invalid username' });
    }
    
    db.collection('users').findOne({ username: username }, (err, user) => {
        if (err) return res.status(500).json({ error: 'Database error' });
        if (!user) return res.status(404).json({ error: 'User not found' });
        res.json(user);
    });
});

# Insecure Design
# 7

@app.route('/reset-password', methods=['POST'])
def reset_password():
    token = request.form.get('token')
    new_password = request.form.get('new_password')
    
    if not token or not new_password:
        return jsonify({'error': 'Missing required fields'}), 400
    
    
    user = User.query.filter_by(reset_token=token).first()
    if not user or user.token_expires < datetime.now():
        return jsonify({'error': 'Invalid or expired token'}), 400
    
    user.password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
    user.reset_token = None
    user.token_expires = None
    db.session.commit()
    
    return jsonify({'message': 'Password reset successful'})

# Software and Data Integrity Failures
# 8

<script src="https://cdn.example.com/lib.js" integrity="sha384-"></script>


</script>

# Server-Side Request Forgery
# 9

def is_safe_url(url):
    try:
        parsed = urlparse(url)
        
        if parsed.scheme not in ['http', 'https']:
            return False
    
        hostname = parsed.hostname
        if hostname in ['localhost', '127.0.0.1'] or hostname.startswith('192.168.') or hostname.startswith('10.'):
            return False
        return True
    except:
        return False

url = input("Enter URL: ")
if not is_safe_url(url):
    print("Error: Invalid or unsafe URL")
else:
    response = requests.get(url, timeout=5)
    print(response.text)

# Identification and Authentication Failures
# 10

hashedPassword = hash(inputPassword + salt)
store(hashedPassword, salt)

inputHash = hash(inputPassword + storedSalt)
if(inputHash.equals(storedHashedPassword)) {
    // Login success
}